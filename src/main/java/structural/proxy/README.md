# 代理模式

## 定义
> 为其他对象提供一种代理以控制对这个对象的访问。

## 实现
* 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
* 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
* 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。

## 使用
### 何时使用 
* 想在访问一个类时做一些控制
* 需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理
* 若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理，否则可使用cglib

### 关键点
* 静态代理选择的关键点是是否要复用被代理的部分功能
* 动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点

## 使用场景
1. 远程代理:可以隐藏一个对象存在于不同地址空间的事实
2. 虚拟代理:允许内存开销较大的对象在需要的时候创建
3. 安全代理:用来控制对真实对象的访问权限。
4. 智能代理:当调用真实对象时，代理处理另外一些事情

## 分类
### 静态代理
1. 代理类一般要持有一个被代理的对象的引用。
2. 对于我们不关心的方法，全部委托给被代理的对象处理。
3. 自己处理我们关心的方法。

* 可以做到在不修改目标对象的功能前提下,对目标功能扩展.
* 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

### 动态代理
1. 代理对象,不需要实现接口
2. 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
3. 动态代理也叫做:JDK代理,接口代理
4. 实现一个InvocationHandler接口，并且调用Proxy的静态方法去产生代理类

* 动态代理有一个强制性要求，就是被代理的类必须实现了某一个接口，或者本身就是接口。

### cglib代理

## 注意事项
1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
3. 适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口
